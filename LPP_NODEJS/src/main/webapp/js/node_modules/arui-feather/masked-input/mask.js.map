{"version":3,"sources":["masked-input/mask.js"],"names":["PLACEHOLDER_CHAR","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","DEFAULT_FORMAT_CHARACTERS","validate","char","test","a","A","transform","toUpperCase","Mask","mask","formatCharacters","pattern","Pattern","length","firstEditableIndex","lastEditableIndex","index","isEditableIndex","value","formattedValue","cleanValue","replace","cleanValueLength","cleanValueIndex","cleanValueChar","patternIndex","patternLength","charAt","isValidAtIndex"],"mappings":"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","file":"mask.js","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport InputMask from 'inputmask-core';\n\n// Стандартный плейсхолдер буквы равный по ширине цифровому символу.\nconst PLACEHOLDER_CHAR = '\\u2007';\n\n// Стандартные formatCharacters из inputmask-core.\nconst DIGIT_RE = /^\\d$/;\nconst LETTER_RE = /^[A-Za-z]$/;\nconst ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/;\n\n/**\n * @typedef {Object} CharFormatter\n * @property {Function} validate Предикат-фильтр\n * @property {Function} [transform] Действия с символом\n */\n\n/**\n * @typedef {Object.<string, CharFormatter>} FormatCharacters\n */\n\n/**\n * @type FormatCharacters\n */\nconst DEFAULT_FORMAT_CHARACTERS = {\n    '*': {\n        validate(char) { return ALPHANNUMERIC_RE.test(char); }\n    },\n    1: {\n        validate(char) { return DIGIT_RE.test(char); }\n    },\n    a: {\n        validate(char) { return LETTER_RE.test(char); }\n    },\n    A: {\n        validate(char) { return LETTER_RE.test(char); },\n        transform(char) { return char.toUpperCase(); }\n    },\n    '#': {\n        validate(char) { return ALPHANNUMERIC_RE.test(char); },\n        transform(char) { return char.toUpperCase(); }\n    }\n};\n\n/**\n * Класс маски. Позволяет форматировать строку по заданной маске.\n *\n * @class\n * @param {String} mask Маска в формате: https://github.com/insin/inputmask-core\n * @param {FormatCharacters} [formatCharacters] Форматтеры маски в формате `inputmask-core`\n */\nclass Mask {\n    /**\n     * Длина маски.\n     *\n     * @public\n     * @type {Number}\n     */\n    length;\n\n    /**\n     * Индекс первого редактируемого символа.\n     *\n     * @public\n     * @type {Number}\n     */\n    firstEditableIndex;\n\n    /**\n     * Индекс последнего редактируемого символа.\n     *\n     * @public\n     * @type {Number}\n     */\n    lastEditableIndex;\n\n    /**\n     * @type {InputMask.Pattern}\n     */\n    pattern;\n\n    constructor(mask, formatCharacters) {\n        this.pattern = new InputMask.Pattern(\n            mask,\n            { ...DEFAULT_FORMAT_CHARACTERS, ...formatCharacters },\n            PLACEHOLDER_CHAR\n        );\n\n        this.length = this.pattern.length;\n        this.firstEditableIndex = this.pattern.firstEditableIndex;\n        this.lastEditableIndex = this.pattern.lastEditableIndex;\n    }\n\n    /**\n     * Проверяет является ли символ в заданном индексе редактируемым.\n     *\n     * @param {Number} index Индекс символа.\n     * @returns {Boolean}\n     */\n    isEditableIndex(index) {\n        return this.pattern.isEditableIndex(index);\n    }\n\n    /**\n     * Форматирует значение введенное в поле ввода по маске.\n     *\n     * @param {String} value Неформатированное значение из поля ввода.\n     * @returns {String}\n     */\n    format(value) {\n        let formattedValue = '';\n\n        let cleanValue = value.replace(/\\s+/g, '');\n        let cleanValueLength = cleanValue.length;\n        let cleanValueIndex = 0;\n        let cleanValueChar;\n\n        let patternIndex = 0;\n        let patternLength = this.pattern.length;\n\n        while (patternIndex < patternLength && cleanValueIndex < cleanValueLength) {\n            if (!this.pattern.isEditableIndex(patternIndex)) {\n                formattedValue += this.pattern.pattern[patternIndex];\n                patternIndex += 1;\n            } else {\n                while ((cleanValueChar = cleanValue.charAt(cleanValueIndex)) !== '') { // eslint-disable-line no-cond-assign\n                    if (this.pattern.isValidAtIndex(cleanValueChar, patternIndex)) {\n                        formattedValue += this.pattern.transform(cleanValueChar, patternIndex);\n                        patternIndex += 1;\n                        cleanValueIndex += 1;\n                        break;\n                    } else {\n                        cleanValueIndex += 1;\n                    }\n                }\n            }\n        }\n\n        return formattedValue;\n    }\n}\n\nexport default Mask;\n"]}