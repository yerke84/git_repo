{"version":3,"sources":["lib/date-utils.js"],"names":["normalizeDate","getRussianWeekDay","parse","DAYS_IN_WEEK","date","Date","sunday","foreignWeekDayIndex","getDay","PARSE_TOKENS","type","regex","formatRegex","getLimits","month","year","min","max","Number","MAX_SAFE_INTEGER","PARSER_CACHE","parseFormat","format","parser","processingFormat","length","matchedToken","find","match","t","push","replace","value","substring","input","strict","parsedFormat","parsedResult","i","token","parseInt","dateLimits","monthLimits","yearLimits"],"mappings":"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","file":"date-utils.js","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/* eslint no-continue: 0 */\n\nimport getDaysInMonth from 'date-fns/get_days_in_month';\n\nconst DAYS_IN_WEEK = 7;\n\n/**\n * Нормализирует дату, возвращает Date в независтимости от входных данных.\n *\n * @param {Date|Number} date Дата для нормализации.\n * @returns {Date}\n */\nexport function normalizeDate(date) {\n    return new Date(date);\n}\n\n/**\n * Возвращает \"правильный\" индекс дня недели, 0 - пн, 1 - вт и так далее.\n *\n * @param {Date} date Дата, из которой нужно получить день недели.\n * @returns {Number}\n */\nexport function getRussianWeekDay(date) {\n    let sunday = 0;\n    let foreignWeekDayIndex = date.getDay();\n\n    return foreignWeekDayIndex === sunday\n        ? DAYS_IN_WEEK - 1\n        : foreignWeekDayIndex - 1;\n}\n\nconst PARSE_TOKENS = [\n    { type: 'date', regex: /^\\d{2}/, formatRegex: /^DD/ },\n    { type: 'date', regex: /^\\d{1,2}/, formatRegex: /^D/ },\n    { type: 'month', regex: /^\\d{2}/, formatRegex: /^MM/ },\n    { type: 'month', regex: /^\\d{1,2}/, formatRegex: /^M/ },\n    { type: 'year', regex: /^\\d{4}/, formatRegex: /^YYYY/ }\n];\n\n/**\n * @typedef {Object} Limit\n * @property {Number} min Минимально возможное значение.\n * @property {Number} max Максимально возможное значение.\n */\n\n/**\n * @typedef {Object} DateLimits\n * @property {Limit} date Лимиты для дня.\n * @property {Limit} month Лимиты для месяца.\n * @property {Limit} year Лимиты для года.\n */\n\n/**\n * Возвращает граничные значения для дня, месяца, года.\n *\n * @param {Number} month Месяц в котором нужно получить максимально возможное число дней.\n * @param {Number} year Год месяца в котором нужно получить максимально возможное число дней.\n * @returns {DateLimits}\n */\nfunction getLimits(month, year) {\n    return {\n        date: { min: 1, max: getDaysInMonth(new Date(year, month - 1)) },\n        month: { min: 1, max: 12 },\n        year: { min: 1, max: Number.MAX_SAFE_INTEGER }\n    };\n}\n\n/**\n * @typedef {Object} FormatParserToken\n * @property {String} type Тип токена.\n * @property {RegExp} formatRegex Для всех типов кроме 'delimiter'. Регулярное выражение, соответствующее формату\n * @property {RegExp} regex Для всех типов кроме 'delimiter'. Регулярное выражение для проверки соответствия формату\n * @property {String} value Только для типа 'delimiter'. Символ разделитель.\n */\n\nconst PARSER_CACHE = {};\n\n/**\n * Разбирает строку с форматом даты.\n *\n * @param {String} format формат даты для разбора.\n * @returns {Array<FormatParserToken>}\n */\nfunction parseFormat(format) {\n    if (PARSER_CACHE[format]) {\n        return PARSER_CACHE[format];\n    }\n\n    let parser = [];\n    let processingFormat = format;\n\n    while (processingFormat.length > 0) {\n        /* eslint no-loop-func: 0 */\n        let matchedToken = PARSE_TOKENS.find(t => processingFormat.match(t.formatRegex));\n        if (matchedToken) {\n            parser.push(matchedToken);\n            processingFormat = processingFormat.replace(matchedToken.formatRegex, '');\n        } else {\n            parser.push({ type: 'delimiter', value: processingFormat[0] });\n            processingFormat = processingFormat.substring(1);\n        }\n    }\n\n    PARSER_CACHE[format] = parser;\n    return parser;\n}\n\n/**\n * Разбирает дату из строки по заданному формату.\n * Допустимые элементы формата:\n * D - дата, в формате 1-31\n * DD - дата, в формате 01-31,\n * M - месяц, в формате 1-12,\n * MM - месяц, в формате 01-12\n * YYYY - год\n * В качестве разделителей между элементами даты могут выступать любые символы, не являющиеся частью формата.\n *\n * @param {String} input Входная строка для разбора.\n * @param {String} [format='DD.MM.YYYY'] Формат, который будет использоваться для разбора.\n * @param {Boolean} [strict=true] Запрещать ли значения, выходящие за пределы логических ограничений месяцев/дней.\n * В случае если strict=false 22 месяц будет интерпретироваться как год и 10 месяцев.\n * @returns {Date}\n */\nexport function parse(input, format = 'DD.MM.YYYY', strict = true) {\n    let parsedFormat = parseFormat(format);\n    let parsedResult = {};\n    for (let i = 0; i < parsedFormat.length; i++) {\n        let token = parsedFormat[i];\n        if (token.type === 'delimiter') {\n            if (input[0] !== token.value) {\n                return new Date('invalid');\n            }\n            input = input.substring(1);\n            continue;\n        }\n\n        let match = input.match(token.regex);\n        if (!match) {\n            return new Date('invalid');\n        }\n\n        parsedResult[token.type] = parseInt(match[0], 10);\n        input = input.replace(token.regex, '');\n    }\n\n    let {\n        date: dateLimits,\n        month: monthLimits,\n        year: yearLimits\n    } = getLimits(parsedResult.month, parsedResult.year);\n\n    if (\n        strict && (\n            parsedResult.date > dateLimits.max || parsedResult.date < dateLimits.min\n            || parsedResult.month > monthLimits.max || parsedResult.month < monthLimits.min\n            || parsedResult.year > yearLimits.max || parsedResult.year < yearLimits.min\n        )\n    ) {\n        return new Date('invalid');\n    }\n\n    return new Date(parsedResult.year, parsedResult.month - 1, parsedResult.date || 1);\n}\n"]}